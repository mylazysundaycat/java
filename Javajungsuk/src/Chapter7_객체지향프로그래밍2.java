
public class Chapter7_객체지향프로그래밍2 {
	public static void main(String[] args) {
		/*
		 상속
		 
		 class Parent {}
		 calss Child extends Parent {}
		 
		 - 자손클래스는 조상클래스의 모든 멤버를 상속받는다. 
		 (단, 생성자와 초기화 블럭은 상속되지 않는다.)
		 - 자손클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.
		 
		 : 자바는 단일상속만을 허용한다
		 
		 */
		
		
		/*
		 상속과 포함, 클래스 간의 관계 결정하기
		 
		 상속관계: A는 B이다 (is -a)
		 포함관계: A는 B를 가지고있다. (has -a)
		 
		 스포츠카는 카이다. (상속)
		 원은 점을 가지고있다. (포함)
		 
		 */
		
		
		/*
		 오버라이딩(overriding)
		 : 조상클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라고 한다.
		 상속받은 메서드를 그대로 사용하기도 하지만, 자손클래스 자신에 맞게 변경해야 하는경우에 쓰인다.
		 */
		
		/*
		 접근제어자
		 넓은것에서 좁은것으로: public -> protected -> default -> private
		 */
		
		/*
		 오버라이딩의 조건
		 1. 선언부가 조상클래스의 메서드와 일치해야한다. 구현부는 수정할 수 있다.
		 2. 접근제어자는 조상클래스의 메서드보다 좁은 범위로 변경할 수 없다.
		 3. 조상클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.
		 */
		
		/*
		 오버로딩과 오버라이딩
		 오버로딩: 한 클래스 내에 같은 이름의 메서드를 여러개 정의하는것 -> 새로운 메서드 추가
		 오버라이딩: 상속받은 메서드의 내용을 변경하는 것
		 */
		
		
		/*
		 static
		 클래스 변수는 인스턴스에 관계없이 같은 값을 갖는다. 그 이유는 하나의 변수를 모든 인스턴스가 공유하기
		 때문이다.
		 : 멤버변수, 메서드, 초기화블럭에 사용됨
		 */
		
		/*
		 final
		 마지막의, 변경될 수 없는 --> 모든 대상에 사용될 수 있다.
		 변수에 사용되면 상수가 되고 메서드에 사용되면 오버라이딩을 할 수없게 되고 클래스에 사용되면
		 자손 클래스를 정의할 수 없게됨.
		 
		 */

		/*
		 abstarct
		 class -> 클래스 내에 추상 메서드가 선언되어 있음을 의미한다.
		 method -> 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다.
		 추상클래스는 아직 완성되지 않은 미완성 설계도이므로 인스턴스를 생성할 수 없다.
		 : 상속을 통해서 자손클래스에 의해서만 완성될 수 있다!
		 : 따라서 상속이 강제된다는 것을 쉽게 알수있음.
		 */
		
		/*
		 접근 제어자
		 public > protected > default > private
		 
		 public: 전체 접근 가능
		 protected: 같은 패키지 내, 다른 패키지의 자손클래스에서 접근 가능
		 default: 같은 패키지 내에서만 가능
		 private: 같은 클래스 내에서만 가능
		 */
		
		/*
		 객체지향개념의 캡슐화(=데이터 감추기)
		 : 접근제어자의 존재 이유
		 1. 외부로부터 데이터를 보호하기 위해서
		 2. 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서

		 */
		
		/*
		 다형성
		 tv t = new tv();
		 smartTv s = new smartTv();
		 조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다
		 반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다.
		 */
		
		/*
		 참조변수의 형변환
		 자손타입의 참조변수를 조상타입의 참조변수로, 조상타입의 참조변수를 자손타입의 참조변수로(캐스팅 생략 불가)
		 형변환이 가능하다.
		 */
		
		/*
		 instanceof 연산자
		 A instance of B : A(참조변수)가 B(클래스명,타입)으로 변환이 가능한지 검사하는 연산자.
		 주로 조건문에 사용된다.
		 */
		
		/*
		 Vector클래스
		 배열에 객체가 추가되거나 제거되거나 하는 등 동적으로관리되는 클래스
		 */
		
		/*
		 상속이 자손클래스를 만드는데 조상클래스를 사용 하는것이라면,
		 추상화는 기존의 클래스의 공통부분을 뽑아 조상클래스를 만드는 것이다.
		 
		 상속계층도를 따라 내려갈 수록 클래스는 기능이 점점 추가되어 '구체화'가 될 것이고
		 상속계층도를 따라 올라갈 수록 클래스의 '추상화'정도가 심해질 것이다.
		 */
		
		/*
		 인터페이스
		 인터페이스는 구현된 것은 아무것도 없고, 밑그림만 그려져있는 기본 설계도이다.
		 오직 추상 메서드와 상수만을 멤버로 가질 수 있다.
		 인터페이스는 접근제어자로 public 혹은 default만 사용할 수 있다.
		 : 모든 멤버변수는 public static final 이여야 하며 생략할 수 있다.
		 : 모든 메서드는 public abstract 이어야 하며 생략할 수 있다
		 
		 인터페이스는 인터페이스로부터만 상속받을 수 있으며, 다중상속이 가능함.
		 
		 interface Fightable {}
		 class Fighter implements Fightable {
		 	Fightable method() {
		 		Fighter f = new Fighter();
		 		return f; // = return new Fighter();
		 	}
		 }
		 	
		 리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의
		 인스턴스를 반환한다는 것을 의미한다.

		 */
		
		/*
		 인터페이스의 장점
		 1. 개발시간을 단축시킬 수있다.
		 2. 표준화가 가능하다
		 3. 서로 관계없는 클래스에게 관계를 맺어줄 수있다.
		 4. 독립적인 프로그래밍이 가능하다.
		 */
		
		/*
		 인터페이스 - 디폴트 메서드, 스태틱 메서드
		 인터페이스에는 추상 메서드만 추가가 가능했다. 그러나 JDK1.8부터
		 디폴트 메서드와 스태틱 메서드도 추가할 수 있게 되었다.
		 public abstract void newMethod();
		 -> public default void newMethod(){}
		 
		 디폴트 메소드의 장점은, 인터페이스에 새롭게 추가해도 자손부가 해당 메소드를
		 새롭게 정의하지 않아도 된다는 것이다. 다만 기존의 메서드와 이름이 중복되어
		 충돌하는 경우가 발생한다면 이를 해결하는 규칙은 다음과 같다.
		 
		 1. 여러 인터페이스에서 디폴트 메서드간의 충돌
		 : 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩 해야한다.
		 2. 디폴트 메서드와 조상 클래스의 메서드간의 충돌
		 : 조상 클래스의 메서드가 상속되고 디폴트 메서드는 무시된다.
		 */
		
		/*
		 내부 클래스(inner class)
		 1. 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.
		 2. 코드의 복잡성을 줄일 수 있다.(캡슐화)
		 내부 클래스는 일반적으로 스태틱 변수를 가질수 없지만,
		 스태틱 내부 클래스는 스태틱 멤버를 정의할 수 있다.
		 */
		
		/*
		 익명 클래스(anonymous class)
		 클래스의 선언과 객체를 동시에 하기 때문에 단 한번만 사용될 수 있고 오직 하나의 객체만을
		 생성할 수 있는 일회용 클래스이다.
		 */
		
		
	}
}
